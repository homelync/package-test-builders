"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const logger = require("winston");
const asyncLocalStore_1 = require("../scope/asyncLocalStore");
const path_1 = require("path");
const dotenv_1 = require("dotenv");
const fs = require('fs');
const env = process.env;
const nodeEnv = env.NODE_ENV || 'local';
// Support both ts-node and deployed packages. 
// Check for a ts-node environment first
let path = path_1.resolve(__dirname, `../../../../src/env/.env.${nodeEnv}`);
if (!fs.existsSync(path)) {
    // If not found, look for a packaged environment e.g. lambda.
    path = path_1.resolve(__dirname, `../../../../env/.env.${nodeEnv}`);
}
dotenv_1.config({ path: path });
console.log(`Setting loglevel to '${env.LOG_LEVEL}' using environmentPath: ${path}`);
const { timestamp, printf } = logger.format;
const os = require('os');
const LEVEL = Symbol.for('level');
const MESSAGE = Symbol.for('message');
exports.format = (info) => {
    const correlationId = asyncLocalStore_1.getCorrelationId();
    let message = info.message;
    // byprodct of supporting json messages
    if (message.startsWith('"') && message.endsWith('"')) {
        message = message.slice(1, -1);
    }
    // Add a zero event code if not supplied in the message, again for streaming to lambda
    const eventIdRegex = new RegExp('^#[0-9]+');
    const eventIdMatch = eventIdRegex.exec(message);
    if (!(eventIdMatch === null || eventIdMatch === void 0 ? void 0 : eventIdMatch.length)) {
        message = '0 ' + message;
    }
    else {
        message = message.replace(eventIdMatch.toString(), eventIdMatch.toString().replace('#', ''));
    }
    // Add event type
    const words = message.split(' ');
    const type = words[1];
    const typeRegEx = new RegExp('#[a-z]+#');
    const typeMatch = typeRegEx.exec(type);
    if (typeMatch === null || typeMatch === void 0 ? void 0 : typeMatch.length) {
        message = message.replace(type, typeMatch.toString().replace(/#/g, ''));
    }
    else {
        const typeIndex = message.indexOf(' ');
        message = [message.slice(0, typeIndex), ' log', message.slice(typeIndex)].join('');
    }
    return `[${info.level}] ${env.NODE_ENV} ${env.BASE_LAMBDA_NAME} ${os.hostname()} ${correlationId} ${message.replace(/(\r\n|\n|\r)/gm, '')}`;
};
const consoleFormat = printf(info => {
    return exports.format(info);
});
logger.configure({
    level: env.LOG_LEVEL,
    format: logger.format.combine(timestamp(), consoleFormat),
    transports: [
        new logger.transports.Console({
            //
            // This is required as ecs logs do not listen to stdout but rather console.log
            // this override intercepts stdout and redirects to console.log
            //
            log(info, callback) {
                setImmediate(() => this.emit('logged', info));
                if (this.stderrLevels && this.stderrLevels[info[LEVEL]]) {
                    console.error(info[MESSAGE]);
                    if (callback) {
                        callback();
                    }
                    return;
                }
                console.log(info[MESSAGE]);
                if (callback) {
                    callback();
                }
            }
        })
    ]
});
exports.stream = {
    write: function (message, encoding) {
        logger.info(message);
    }
};
class Logger {
    static log(...args) {
        if (Logger.shouldLog)
            Logger.console.debug(Logger.formatArgs(args));
    }
    static warn(...args) {
        if (Logger.shouldLog)
            Logger.console.warn(Logger.formatArgs(args));
    }
    static error(...args) {
        if (Logger.shouldLog)
            Logger.console.error(Logger.formatArgs(args));
    }
    static info(...args) {
        if (Logger.shouldLog)
            Logger.console.info(Logger.formatArgs(args));
    }
    static verbose(...args) {
        if (Logger.shouldLog)
            Logger.console.verbose(Logger.formatArgs(args));
    }
    static debug(...args) {
        if (Logger.shouldLog)
            Logger.console.debug(Logger.formatArgs(args));
    }
    static formatArgs(args) {
        const replaceErrors = (value) => {
            if (value instanceof Error) {
                var error = {};
                Object.getOwnPropertyNames(value).forEach(x => error[x] = value[x]);
                return error;
            }
            return value;
        };
        const getCircularReplacer = () => {
            const seen = new WeakSet();
            return (key, value) => {
                if (typeof value === "object" && value !== null) {
                    if (seen.has(value)) {
                        return;
                    }
                    seen.add(value);
                }
                return replaceErrors(value);
            };
        };
        if (args.length <= 1)
            args = args[0];
        return JSON.stringify(args, getCircularReplacer(), 4);
    }
}
exports.Logger = Logger;
Logger.shouldLog = true;
Logger.console = logger;
//# sourceMappingURL=logger.js.map